#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class AnEnum(Enum):
    ONE = <int> (AnEnum__ONE)
    TWO = <int> (AnEnum__TWO)
    THREE = <int> (AnEnum__THREE)
    FOUR = <int> (AnEnum__FOUR)

cdef cAnEnum AnEnum_to_cpp(value):
    if value == AnEnum.ONE:
        return AnEnum__ONE
    elif value == AnEnum.TWO:
        return AnEnum__TWO
    elif value == AnEnum.THREE:
        return AnEnum__THREE
    elif value == AnEnum.FOUR:
        return AnEnum__FOUR


cdef class SimpleException(thrift.py3.exceptions.Error):

    def __init__(
        SimpleException self,
        err_code=None
    ):
        self.c_SimpleException = make_shared[cSimpleException]()

        inst = self
        if err_code is not None:
            deref(inst.c_SimpleException).err_code = err_code
            deref(inst.c_SimpleException).__isset.err_code = True



    def __iter__(self):
        yield 'err_code', self.err_code

    def __bool__(self):
        return deref(self.c_SimpleException).__isset.err_code

    @staticmethod
    cdef create(shared_ptr[cSimpleException] c_SimpleException):
        inst = <SimpleException>SimpleException.__new__(SimpleException)
        inst.c_SimpleException = c_SimpleException
        return inst

    @property
    def err_code(self):
        if not deref(self.c_SimpleException).__isset.err_code:
            return None

        return self.c_SimpleException.get().err_code


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleException) and
                isinstance(other, SimpleException)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleException cself = deref((<SimpleException>self).c_SimpleException)
        cdef cSimpleException cother = deref((<SimpleException>other).c_SimpleException)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(SimpleException self):
        return super().__hash__()

    def __repr__(SimpleException self):
        return f'SimpleException(err_code={repr(self.err_code)})'


cdef class SimpleStruct(thrift.py3.types.Struct):

    def __init__(
        SimpleStruct self,
        is_on=None,
        tiny_int=None,
        small_int=None,
        nice_sized_int=None,
        big_int=None,
        real=None,
        smaller_real=None
    ):
        self.c_SimpleStruct = make_shared[cSimpleStruct]()

        inst = self
        if is_on is not None:
            deref(inst.c_SimpleStruct).is_on = is_on
            deref(inst.c_SimpleStruct).__isset.is_on = True

        if tiny_int is not None:
            deref(inst.c_SimpleStruct).tiny_int = tiny_int
            deref(inst.c_SimpleStruct).__isset.tiny_int = True

        if small_int is not None:
            deref(inst.c_SimpleStruct).small_int = small_int
            deref(inst.c_SimpleStruct).__isset.small_int = True

        if nice_sized_int is not None:
            deref(inst.c_SimpleStruct).nice_sized_int = nice_sized_int
            deref(inst.c_SimpleStruct).__isset.nice_sized_int = True

        if big_int is not None:
            deref(inst.c_SimpleStruct).big_int = big_int
            deref(inst.c_SimpleStruct).__isset.big_int = True

        if real is not None:
            deref(inst.c_SimpleStruct).real = real
            deref(inst.c_SimpleStruct).__isset.real = True

        if smaller_real is not None:
            deref(inst.c_SimpleStruct).smaller_real = smaller_real
            deref(inst.c_SimpleStruct).__isset.smaller_real = True


    cdef bytes _serialize(SimpleStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cSimpleStruct](deref(self.c_SimpleStruct.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cSimpleStruct](deref(self.c_SimpleStruct.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cSimpleStruct](deref(self.c_SimpleStruct.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(SimpleStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cSimpleStruct](buf, deref(self.c_SimpleStruct.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cSimpleStruct](buf, deref(self.c_SimpleStruct.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cSimpleStruct](buf, deref(self.c_SimpleStruct.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (SimpleStruct, serialize(self)))

    def __call__(
        SimpleStruct self,
        is_on=NOTSET,
        tiny_int=NOTSET,
        small_int=NOTSET,
        nice_sized_int=NOTSET,
        big_int=NOTSET,
        real=NOTSET,
        smaller_real=NOTSET
    ):
        changes = any((
            is_on is not NOTSET,

            tiny_int is not NOTSET,

            small_int is not NOTSET,

            nice_sized_int is not NOTSET,

            big_int is not NOTSET,

            real is not NOTSET,

            smaller_real is not NOTSET,
        ))

        if not changes:
            return self

        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst.c_SimpleStruct = make_shared[cSimpleStruct](deref(self.c_SimpleStruct))
        cdef SimpleStruct defaults = SimpleStruct_defaults

        # Convert None's to default value.
        if is_on is None:
            deref(inst.c_SimpleStruct).is_on = deref(defaults.c_SimpleStruct).is_on
            deref(inst.c_SimpleStruct).__isset.is_on = False
        if is_on is NOTSET:
            is_on = None
        if tiny_int is None:
            deref(inst.c_SimpleStruct).tiny_int = deref(defaults.c_SimpleStruct).tiny_int
            deref(inst.c_SimpleStruct).__isset.tiny_int = False
        if tiny_int is NOTSET:
            tiny_int = None
        if small_int is None:
            deref(inst.c_SimpleStruct).small_int = deref(defaults.c_SimpleStruct).small_int
            deref(inst.c_SimpleStruct).__isset.small_int = False
        if small_int is NOTSET:
            small_int = None
        if nice_sized_int is None:
            deref(inst.c_SimpleStruct).nice_sized_int = deref(defaults.c_SimpleStruct).nice_sized_int
            deref(inst.c_SimpleStruct).__isset.nice_sized_int = False
        if nice_sized_int is NOTSET:
            nice_sized_int = None
        if big_int is None:
            deref(inst.c_SimpleStruct).big_int = deref(defaults.c_SimpleStruct).big_int
            deref(inst.c_SimpleStruct).__isset.big_int = False
        if big_int is NOTSET:
            big_int = None
        if real is None:
            deref(inst.c_SimpleStruct).real = deref(defaults.c_SimpleStruct).real
            deref(inst.c_SimpleStruct).__isset.real = False
        if real is NOTSET:
            real = None
        if smaller_real is None:
            deref(inst.c_SimpleStruct).smaller_real = deref(defaults.c_SimpleStruct).smaller_real
            deref(inst.c_SimpleStruct).__isset.smaller_real = False
        if smaller_real is NOTSET:
            smaller_real = None

        if is_on is not None:
            deref(inst.c_SimpleStruct).is_on = is_on
            deref(inst.c_SimpleStruct).__isset.is_on = True

        if tiny_int is not None:
            deref(inst.c_SimpleStruct).tiny_int = tiny_int
            deref(inst.c_SimpleStruct).__isset.tiny_int = True

        if small_int is not None:
            deref(inst.c_SimpleStruct).small_int = small_int
            deref(inst.c_SimpleStruct).__isset.small_int = True

        if nice_sized_int is not None:
            deref(inst.c_SimpleStruct).nice_sized_int = nice_sized_int
            deref(inst.c_SimpleStruct).__isset.nice_sized_int = True

        if big_int is not None:
            deref(inst.c_SimpleStruct).big_int = big_int
            deref(inst.c_SimpleStruct).__isset.big_int = True

        if real is not None:
            deref(inst.c_SimpleStruct).real = real
            deref(inst.c_SimpleStruct).__isset.real = True

        if smaller_real is not None:
            deref(inst.c_SimpleStruct).smaller_real = smaller_real
            deref(inst.c_SimpleStruct).__isset.smaller_real = True

        return inst

    def __iter__(self):
        yield 'is_on', self.is_on
        yield 'tiny_int', self.tiny_int
        yield 'small_int', self.small_int
        yield 'nice_sized_int', self.nice_sized_int
        yield 'big_int', self.big_int
        yield 'real', self.real
        yield 'smaller_real', self.smaller_real

    def __bool__(self):
        return deref(self.c_SimpleStruct).__isset.is_on or deref(self.c_SimpleStruct).__isset.tiny_int or deref(self.c_SimpleStruct).__isset.small_int or deref(self.c_SimpleStruct).__isset.nice_sized_int or deref(self.c_SimpleStruct).__isset.big_int or deref(self.c_SimpleStruct).__isset.real or deref(self.c_SimpleStruct).__isset.smaller_real

    @staticmethod
    cdef create(shared_ptr[cSimpleStruct] c_SimpleStruct):
        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst.c_SimpleStruct = c_SimpleStruct
        return inst

    @property
    def is_on(self):
        if not deref(self.c_SimpleStruct).__isset.is_on:
            return None

        return <pbool> self.c_SimpleStruct.get().is_on

    @property
    def tiny_int(self):
        if not deref(self.c_SimpleStruct).__isset.tiny_int:
            return None

        return self.c_SimpleStruct.get().tiny_int

    @property
    def small_int(self):
        if not deref(self.c_SimpleStruct).__isset.small_int:
            return None

        return self.c_SimpleStruct.get().small_int

    @property
    def nice_sized_int(self):
        if not deref(self.c_SimpleStruct).__isset.nice_sized_int:
            return None

        return self.c_SimpleStruct.get().nice_sized_int

    @property
    def big_int(self):
        if not deref(self.c_SimpleStruct).__isset.big_int:
            return None

        return self.c_SimpleStruct.get().big_int

    @property
    def real(self):
        if not deref(self.c_SimpleStruct).__isset.real:
            return None

        return self.c_SimpleStruct.get().real

    @property
    def smaller_real(self):
        if not deref(self.c_SimpleStruct).__isset.smaller_real:
            return None

        return self.c_SimpleStruct.get().smaller_real


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleStruct) and
                isinstance(other, SimpleStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleStruct cself = deref((<SimpleStruct>self).c_SimpleStruct)
        cdef cSimpleStruct cother = deref((<SimpleStruct>other).c_SimpleStruct)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(SimpleStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.is_on,
            self.tiny_int,
            self.small_int,
            self.nice_sized_int,
            self.big_int,
            self.real,
            self.smaller_real,
            ))
        return self.__hash

    def __repr__(SimpleStruct self):
        return f'SimpleStruct(is_on={repr(self.is_on)}, tiny_int={repr(self.tiny_int)}, small_int={repr(self.small_int)}, nice_sized_int={repr(self.nice_sized_int)}, big_int={repr(self.big_int)}, real={repr(self.real)}, smaller_real={repr(self.smaller_real)})'


SimpleStruct_defaults = SimpleStruct()


cdef class ComplexStruct(thrift.py3.types.Struct):

    def __init__(
        ComplexStruct self,
        structOne=None,
        structTwo=None,
        an_integer=None,
        name=None,
        an_enum=None,
        some_bytes=None
    ):
        self.c_ComplexStruct = make_shared[cComplexStruct]()

        inst = self
        cdef shared_ptr[cSimpleStruct] __structOne
        if structOne is not None:
            __structOne = (
            <SimpleStruct?> structOne).c_SimpleStruct
            deref(inst.c_ComplexStruct).structOne = deref(__structOne.get())
            deref(inst.c_ComplexStruct).__isset.structOne = True

        cdef shared_ptr[cSimpleStruct] __structTwo
        if structTwo is not None:
            __structTwo = (
            <SimpleStruct?> structTwo).c_SimpleStruct
            deref(inst.c_ComplexStruct).structTwo = deref(__structTwo.get())
            deref(inst.c_ComplexStruct).__isset.structTwo = True

        if an_integer is not None:
            deref(inst.c_ComplexStruct).an_integer = an_integer
            deref(inst.c_ComplexStruct).__isset.an_integer = True

        if name is not None:
            deref(inst.c_ComplexStruct).name = name.encode('UTF-8')
            deref(inst.c_ComplexStruct).__isset.name = True

        if an_enum is not None:
            deref(inst.c_ComplexStruct).an_enum = AnEnum_to_cpp(an_enum)
            deref(inst.c_ComplexStruct).__isset.an_enum = True

        if some_bytes is not None:
            deref(inst.c_ComplexStruct).some_bytes = some_bytes
            deref(inst.c_ComplexStruct).__isset.some_bytes = True


    cdef bytes _serialize(ComplexStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cComplexStruct](deref(self.c_ComplexStruct.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cComplexStruct](deref(self.c_ComplexStruct.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cComplexStruct](deref(self.c_ComplexStruct.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(ComplexStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cComplexStruct](buf, deref(self.c_ComplexStruct.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cComplexStruct](buf, deref(self.c_ComplexStruct.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cComplexStruct](buf, deref(self.c_ComplexStruct.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexStruct, serialize(self)))

    def __call__(
        ComplexStruct self,
        structOne=NOTSET,
        structTwo=NOTSET,
        an_integer=NOTSET,
        name=NOTSET,
        an_enum=NOTSET,
        some_bytes=NOTSET
    ):
        changes = any((
            structOne is not NOTSET,

            structTwo is not NOTSET,

            an_integer is not NOTSET,

            name is not NOTSET,

            an_enum is not NOTSET,

            some_bytes is not NOTSET,
        ))

        if not changes:
            return self

        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst.c_ComplexStruct = make_shared[cComplexStruct](deref(self.c_ComplexStruct))
        cdef ComplexStruct defaults = ComplexStruct_defaults

        # Convert None's to default value.
        if structOne is None:
            deref(inst.c_ComplexStruct).structOne = deref(defaults.c_ComplexStruct).structOne
            deref(inst.c_ComplexStruct).__isset.structOne = False
        if structOne is NOTSET:
            structOne = None
        if structTwo is None:
            deref(inst.c_ComplexStruct).structTwo = deref(defaults.c_ComplexStruct).structTwo
            deref(inst.c_ComplexStruct).__isset.structTwo = False
        if structTwo is NOTSET:
            structTwo = None
        if an_integer is None:
            deref(inst.c_ComplexStruct).an_integer = deref(defaults.c_ComplexStruct).an_integer
            deref(inst.c_ComplexStruct).__isset.an_integer = False
        if an_integer is NOTSET:
            an_integer = None
        if name is None:
            deref(inst.c_ComplexStruct).name = deref(defaults.c_ComplexStruct).name
            deref(inst.c_ComplexStruct).__isset.name = False
        if name is NOTSET:
            name = None
        if an_enum is None:
            deref(inst.c_ComplexStruct).an_enum = deref(defaults.c_ComplexStruct).an_enum
            deref(inst.c_ComplexStruct).__isset.an_enum = False
        if an_enum is NOTSET:
            an_enum = None
        if some_bytes is None:
            deref(inst.c_ComplexStruct).some_bytes = deref(defaults.c_ComplexStruct).some_bytes
            deref(inst.c_ComplexStruct).__isset.some_bytes = False
        if some_bytes is NOTSET:
            some_bytes = None

        cdef shared_ptr[cSimpleStruct] __structOne
        if structOne is not None:
            __structOne = (
            <SimpleStruct?> structOne).c_SimpleStruct
            deref(inst.c_ComplexStruct).structOne = deref(__structOne.get())
            deref(inst.c_ComplexStruct).__isset.structOne = True

        cdef shared_ptr[cSimpleStruct] __structTwo
        if structTwo is not None:
            __structTwo = (
            <SimpleStruct?> structTwo).c_SimpleStruct
            deref(inst.c_ComplexStruct).structTwo = deref(__structTwo.get())
            deref(inst.c_ComplexStruct).__isset.structTwo = True

        if an_integer is not None:
            deref(inst.c_ComplexStruct).an_integer = an_integer
            deref(inst.c_ComplexStruct).__isset.an_integer = True

        if name is not None:
            deref(inst.c_ComplexStruct).name = name.encode('UTF-8')
            deref(inst.c_ComplexStruct).__isset.name = True

        if an_enum is not None:
            deref(inst.c_ComplexStruct).an_enum = AnEnum_to_cpp(an_enum)
            deref(inst.c_ComplexStruct).__isset.an_enum = True

        if some_bytes is not None:
            deref(inst.c_ComplexStruct).some_bytes = some_bytes
            deref(inst.c_ComplexStruct).__isset.some_bytes = True

        return inst

    def __iter__(self):
        yield 'structOne', self.structOne
        yield 'structTwo', self.structTwo
        yield 'an_integer', self.an_integer
        yield 'name', self.name
        yield 'an_enum', self.an_enum
        yield 'some_bytes', self.some_bytes

    def __bool__(self):
        return deref(self.c_ComplexStruct).__isset.structOne or deref(self.c_ComplexStruct).__isset.structTwo or deref(self.c_ComplexStruct).__isset.an_integer or deref(self.c_ComplexStruct).__isset.name or deref(self.c_ComplexStruct).__isset.an_enum or deref(self.c_ComplexStruct).__isset.some_bytes

    @staticmethod
    cdef create(shared_ptr[cComplexStruct] c_ComplexStruct):
        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst.c_ComplexStruct = c_ComplexStruct
        return inst

    @property
    def structOne(self):
        if not deref(self.c_ComplexStruct).__isset.structOne:
            return None

        cdef shared_ptr[cSimpleStruct] item
        if self.__structOne is None:
            item = make_shared[cSimpleStruct](
                deref(self.c_ComplexStruct).structOne)
            self.__structOne = SimpleStruct.create(item)
        return self.__structOne
        

    @property
    def structTwo(self):
        if not deref(self.c_ComplexStruct).__isset.structTwo:
            return None

        cdef shared_ptr[cSimpleStruct] item
        if self.__structTwo is None:
            item = make_shared[cSimpleStruct](
                deref(self.c_ComplexStruct).structTwo)
            self.__structTwo = SimpleStruct.create(item)
        return self.__structTwo
        

    @property
    def an_integer(self):
        if not deref(self.c_ComplexStruct).__isset.an_integer:
            return None

        return self.c_ComplexStruct.get().an_integer

    @property
    def name(self):
        if not deref(self.c_ComplexStruct).__isset.name:
            return None

        return self.c_ComplexStruct.get().name.decode('UTF-8')

    @property
    def an_enum(self):
        if not deref(self.c_ComplexStruct).__isset.an_enum:
            return None

        cdef int value = <int> deref(self.c_ComplexStruct).an_enum
        try:
            return AnEnum(value)
        except ValueError:
            return thrift.py3.types.BadEnum(AnEnum, value)
        

    @property
    def some_bytes(self):
        if not deref(self.c_ComplexStruct).__isset.some_bytes:
            return None

        return self.c_ComplexStruct.get().some_bytes


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ComplexStruct) and
                isinstance(other, ComplexStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cComplexStruct cself = deref((<ComplexStruct>self).c_ComplexStruct)
        cdef cComplexStruct cother = deref((<ComplexStruct>other).c_ComplexStruct)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(ComplexStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.structOne,
            self.structTwo,
            self.an_integer,
            self.name,
            self.an_enum,
            self.some_bytes,
            ))
        return self.__hash

    def __repr__(ComplexStruct self):
        return f'ComplexStruct(structOne={repr(self.structOne)}, structTwo={repr(self.structTwo)}, an_integer={repr(self.an_integer)}, name={repr(self.name)}, an_enum={repr(self.an_enum)}, some_bytes={repr(self.some_bytes)})'


ComplexStruct_defaults = ComplexStruct()


cdef class List__i16:
    def __init__(self, items=None):
        if isinstance(items, List__i16):
            self._vector = (<List__i16> items)._vector
        else:
          self._vector = make_shared[vector[int16_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int16_t]] c_items):
        inst = <List__i16>List__i16.__new__(List__i16)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef int16_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for citem in deref(self._vector):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef vector[int16_t] vec = deref(
            self._vector.get())
        cdef vector[int16_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._vector.get())
        cdef vector[int16_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i16)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._vector = (<List__i32> items)._vector
        else:
          self._vector = make_shared[vector[int32_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef int32_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._vector):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class List__i64:
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._vector = (<List__i64> items)._vector
        else:
          self._vector = make_shared[vector[int64_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef int64_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        for citem in deref(self._vector):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef vector[int64_t] vec = deref(
            self._vector.get())
        cdef vector[int64_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._vector.get())
        cdef vector[int64_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i64)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._vector = (<List__string> items)._vector
        else:
          self._vector = make_shared[vector[string]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item.encode('UTF-8'))

    @staticmethod
    cdef create(
            shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef string citem = (
            deref(self._vector.get())[index])
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._vector):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._vector.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, List__SimpleStruct):
            self._vector = (<List__SimpleStruct> items)._vector
        else:
          self._vector = make_shared[vector[cSimpleStruct]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref((<SimpleStruct> item).c_SimpleStruct))

    @staticmethod
    cdef create(
            shared_ptr[vector[cSimpleStruct]] c_items):
        inst = <List__SimpleStruct>List__SimpleStruct.__new__(List__SimpleStruct)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cSimpleStruct citem = (
            deref(self._vector.get())[index])
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        for citem in deref(self._vector):
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        cdef vector[cSimpleStruct] vec = deref(
            self._vector.get())
        cdef vector[cSimpleStruct].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(self._vector.get())
        cdef vector[cSimpleStruct].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__SimpleStruct)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._set = (<Set__i32> items)._set
        else:
          self._set = make_shared[cset[int32_t]]()
          if items:
              for item in items:
                  deref(self._set).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._set)
            cother = deref((<Set__i32> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
            if deref((<Set__i32> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._set = (<Set__string> items)._set
        else:
          self._set = make_shared[cset[string]]()
          if items:
              for item in items:
                  deref(self._set).insert(item.encode('UTF-8'))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._set)
            cother = deref((<Set__string> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
            if deref((<Set__string> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._map = (<Map__string_string> items)._map
        else:
          self._map = make_shared[cmap[string,string]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,string](
                          key.encode('UTF-8'),
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

cdef class Map__string_SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_SimpleStruct):
            self._map = (<Map__string_SimpleStruct> items)._map
        else:
          self._map = make_shared[cmap[string,cSimpleStruct]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,cSimpleStruct](
                          key.encode('UTF-8'),
                          deref((<SimpleStruct> item).c_SimpleStruct)))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cSimpleStruct]] c_items):
        inst = <Map__string_SimpleStruct>Map__string_SimpleStruct.__new__(Map__string_SimpleStruct)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cSimpleStruct].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef cSimpleStruct citem = deref(iter).second
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cSimpleStruct].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef cSimpleStruct citem = deref(iter).second
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        for pair in deref(self._map):
            citem = pair.second
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cSimpleStruct citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), SimpleStruct.create(make_shared[cSimpleStruct](citem)))



Mapping.register(Map__string_SimpleStruct)

cdef class Map__string_i16:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i16):
            self._map = (<Map__string_i16> items)._map
        else:
          self._map = make_shared[cmap[string,int16_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,int16_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int16_t]] c_items):
        inst = <Map__string_i16>Map__string_i16.__new__(Map__string_i16)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int16_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef int16_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int16_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int16_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int16_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i16)

cdef class List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._vector = (<List__List__i32> items)._vector
        else:
          self._vector = make_shared[vector[vector[int32_t]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref(List__i32(item)._vector.get()))

    @staticmethod
    cdef create(
            shared_ptr[vector[vector[int32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef vector[int32_t] citem = (
            deref(self._vector.get())[index])
        return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        for citem in deref(self._vector):
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        cdef vector[vector[int32_t]] vec = deref(
            self._vector.get())
        cdef vector[vector[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(self._vector.get())
        cdef vector[vector[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._map = (<Map__string_i32> items)._map
        else:
          self._map = make_shared[cmap[string,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,int32_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._map = (<Map__string_Map__string_i32> items)._map
        else:
          self._map = make_shared[cmap[string,cmap[string,int32_t]]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,cmap[string,int32_t]](
                          key.encode('UTF-8'),
                          cmap[string,int32_t](deref(Map__string_i32(item)._map.get()))))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,int32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for pair in deref(self._map):
            citem = pair.second
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cmap[string,int32_t] citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem)))



Mapping.register(Map__string_Map__string_i32)

cdef class List__Set__string:
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._vector = (<List__Set__string> items)._vector
        else:
          self._vector = make_shared[vector[cset[string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cset[string](deref(Set__string(item)._set.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cset[string] citem = (
            deref(self._vector.get())[index])
        return Set__string.create(
    make_shared[cset[string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        for citem in deref(self._vector):
            yield Set__string.create(
    make_shared[cset[string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        cdef vector[cset[string]] vec = deref(
            self._vector.get())
        cdef vector[cset[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__string.create(
    make_shared[cset[string]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(self._vector.get())
        cdef vector[cset[string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__string)

cdef class Map__string_List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__SimpleStruct):
            self._map = (<Map__string_List__SimpleStruct> items)._map
        else:
          self._map = make_shared[cmap[string,vector[cSimpleStruct]]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,vector[cSimpleStruct]](
                          key.encode('UTF-8'),
                          deref(List__SimpleStruct(item)._vector.get())))

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cSimpleStruct]]] c_items):
        inst = <Map__string_List__SimpleStruct>Map__string_List__SimpleStruct.__new__(Map__string_List__SimpleStruct)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef vector[cSimpleStruct] citem = deref(iter).second
        return List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef vector[cSimpleStruct] citem = deref(iter).second
        return List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._map):
            citem = pair.second
            yield List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem)))



Mapping.register(Map__string_List__SimpleStruct)

cdef class List__List__string:
    def __init__(self, items=None):
        if isinstance(items, List__List__string):
            self._vector = (<List__List__string> items)._vector
        else:
          self._vector = make_shared[vector[vector[string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref(List__string(item)._vector.get()))

    @staticmethod
    cdef create(
            shared_ptr[vector[vector[string]]] c_items):
        inst = <List__List__string>List__List__string.__new__(List__List__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef vector[string] citem = (
            deref(self._vector.get())[index])
        return List__string.create(
    make_shared[vector[string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[string] citem
        for citem in deref(self._vector):
            yield List__string.create(
    make_shared[vector[string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[string] citem
        cdef vector[vector[string]] vec = deref(
            self._vector.get())
        cdef vector[vector[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__string.create(
    make_shared[vector[string]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(self._vector.get())
        cdef vector[vector[string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__string)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._vector = (<List__Set__i32> items)._vector
        else:
          self._vector = make_shared[vector[cset[int32_t]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cset[int32_t](deref(Set__i32(item)._set.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cset[int32_t] citem = (
            deref(self._vector.get())[index])
        return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        for citem in deref(self._vector):
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        cdef vector[cset[int32_t]] vec = deref(
            self._vector.get())
        cdef vector[cset[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(self._vector.get())
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__i32)

cdef class List__Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_string):
            self._vector = (<List__Map__string_string> items)._vector
        else:
          self._vector = make_shared[vector[cmap[string,string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cmap[string,string](deref(Map__string_string(item)._map.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[string,string]]] c_items):
        inst = <List__Map__string_string>List__Map__string_string.__new__(List__Map__string_string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cmap[string,string] citem = (
            deref(self._vector.get())[index])
        return Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,string] citem
        for citem in deref(self._vector):
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,string] citem
        cdef vector[cmap[string,string]] vec = deref(
            self._vector.get())
        cdef vector[cmap[string,string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(self._vector.get())
        cdef vector[cmap[string,string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_string)

cdef class List__binary:
    def __init__(self, items=None):
        if isinstance(items, List__binary):
            self._vector = (<List__binary> items)._vector
        else:
          self._vector = make_shared[vector[string]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[string]] c_items):
        inst = <List__binary>List__binary.__new__(List__binary)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef string citem = (
            deref(self._vector.get())[index])
        return bytes(citem)

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef string citem = item
        cdef vector[string] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._vector):
            yield bytes(citem)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._vector.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef string citem = item
        cdef vector[string] vec = deref(self._vector.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef string citem = item
        cdef vector[string] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__binary)

cdef class Set__binary:
    def __init__(self, items=None):
        if isinstance(items, Set__binary):
            self._set = (<Set__binary> items)._set
        else:
          self._set = make_shared[cset[string]]()
          if items:
              for item in items:
                  deref(self._set).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__binary>Set__binary.__new__(Set__binary)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield bytes(citem)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__binary) and
                isinstance(other, Set__binary)):
            cself = deref((<Set__binary> self)._set)
            cother = deref((<Set__binary> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._set):
            if deref((<Set__binary> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._set):
            if deref((<Set__binary> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__binary> other)._set):
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._set):
            if deref((<Set__binary> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__binary> other)._set):
            if deref((<Set__binary> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__binary)

cdef class List__AnEnum:
    def __init__(self, items=None):
        if isinstance(items, List__AnEnum):
            self._vector = (<List__AnEnum> items)._vector
        else:
          self._vector = make_shared[vector[cAnEnum]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(<cAnEnum> AnEnum_to_cpp(item))

    @staticmethod
    cdef create(
            shared_ptr[vector[cAnEnum]] c_items):
        inst = <List__AnEnum>List__AnEnum.__new__(List__AnEnum)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cAnEnum citem = (
            deref(self._vector.get())[index])
        return AnEnum(<int> citem)

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cAnEnum citem = <cAnEnum> AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cAnEnum citem
        for citem in deref(self._vector):
            yield AnEnum(<int> citem)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cAnEnum citem
        cdef vector[cAnEnum] vec = deref(
            self._vector.get())
        cdef vector[cAnEnum].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield AnEnum(<int> citem)
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cAnEnum citem = <cAnEnum> AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(self._vector.get())
        cdef vector[cAnEnum].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cAnEnum citem = <cAnEnum> AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__AnEnum)

cdef class Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_double):
            self._map = (<Map__i32_double> items)._map
        else:
          self._map = make_shared[cmap[int32_t,double]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[int32_t,double](
                          key,
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,double]] c_items):
        inst = <Map__i32_double>Map__i32_double.__new__(Map__i32_double)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,double].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,double].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef double citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef double citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_double)

cdef class List__Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_double):
            self._vector = (<List__Map__i32_double> items)._vector
        else:
          self._vector = make_shared[vector[cmap[int32_t,double]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cmap[int32_t,double](deref(Map__i32_double(item)._map.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[int32_t,double]]] c_items):
        inst = <List__Map__i32_double>List__Map__i32_double.__new__(List__Map__i32_double)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cmap[int32_t,double] citem = (
            deref(self._vector.get())[index])
        return Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,double] citem
        for citem in deref(self._vector):
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,double] citem
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._vector.get())
        cdef vector[cmap[int32_t,double]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._vector.get())
        cdef vector[cmap[int32_t,double]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i32_double)

A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = cA_WORD().decode('UTF-8')
SOME_BYTES = <bytes> cSOME_BYTES()
A_STRUCT = SimpleStruct.create(
    make_shared[cSimpleStruct](cA_STRUCT()))
WORD_LIST = List__string.create(make_shared[vector[string]](cWORD_LIST()))
SOME_MAP = List__Map__i32_double.create(make_shared[vector[cmap[int32_t,double]]](cSOME_MAP()))
DIGITS = Set__i32.create(make_shared[cset[int32_t]](cDIGITS()))
A_CONST_MAP = Map__string_SimpleStruct.create(make_shared[cmap[string,cSimpleStruct]](cA_CONST_MAP()))
