#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class Animal(Enum):
    DOG = <int> (Animal__DOG)
    CAT = <int> (Animal__CAT)
    TARANTULA = <int> (Animal__TARANTULA)

cdef cAnimal Animal_to_cpp(value):
    if value == Animal.DOG:
        return Animal__DOG
    elif value == Animal.CAT:
        return Animal__CAT
    elif value == Animal.TARANTULA:
        return Animal__TARANTULA


cdef class Color(thrift.py3.types.Struct):

    def __init__(
        Color self,
        red=None,
        green=None,
        blue=None,
        alpha=None
    ):
        self.c_Color = make_shared[cColor]()

        inst = self
        if red is not None:
            deref(inst.c_Color).red = red
            deref(inst.c_Color).__isset.red = True

        if green is not None:
            deref(inst.c_Color).green = green
            deref(inst.c_Color).__isset.green = True

        if blue is not None:
            deref(inst.c_Color).blue = blue
            deref(inst.c_Color).__isset.blue = True

        if alpha is not None:
            deref(inst.c_Color).alpha = alpha
            deref(inst.c_Color).__isset.alpha = True


    cdef bytes _serialize(Color self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cColor](deref(self.c_Color.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cColor](deref(self.c_Color.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cColor](deref(self.c_Color.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Color self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cColor](buf, deref(self.c_Color.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cColor](buf, deref(self.c_Color.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cColor](buf, deref(self.c_Color.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Color, serialize(self)))

    def __call__(
        Color self,
        red=NOTSET,
        green=NOTSET,
        blue=NOTSET,
        alpha=NOTSET
    ):
        changes = any((
            red is not NOTSET,

            green is not NOTSET,

            blue is not NOTSET,

            alpha is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Color>Color.__new__(Color)
        inst.c_Color = make_shared[cColor](deref(self.c_Color))
        cdef Color defaults = Color_defaults

        # Convert None's to default value.
        if red is None:
            deref(inst.c_Color).red = deref(defaults.c_Color).red
            deref(inst.c_Color).__isset.red = False
        if red is NOTSET:
            red = None
        if green is None:
            deref(inst.c_Color).green = deref(defaults.c_Color).green
            deref(inst.c_Color).__isset.green = False
        if green is NOTSET:
            green = None
        if blue is None:
            deref(inst.c_Color).blue = deref(defaults.c_Color).blue
            deref(inst.c_Color).__isset.blue = False
        if blue is NOTSET:
            blue = None
        if alpha is None:
            deref(inst.c_Color).alpha = deref(defaults.c_Color).alpha
            deref(inst.c_Color).__isset.alpha = False
        if alpha is NOTSET:
            alpha = None

        if red is not None:
            deref(inst.c_Color).red = red
            deref(inst.c_Color).__isset.red = True

        if green is not None:
            deref(inst.c_Color).green = green
            deref(inst.c_Color).__isset.green = True

        if blue is not None:
            deref(inst.c_Color).blue = blue
            deref(inst.c_Color).__isset.blue = True

        if alpha is not None:
            deref(inst.c_Color).alpha = alpha
            deref(inst.c_Color).__isset.alpha = True

        return inst

    def __iter__(self):
        yield 'red', self.red
        yield 'green', self.green
        yield 'blue', self.blue
        yield 'alpha', self.alpha

    def __bool__(self):
        return deref(self.c_Color).__isset.red or deref(self.c_Color).__isset.green or deref(self.c_Color).__isset.blue or deref(self.c_Color).__isset.alpha

    @staticmethod
    cdef create(shared_ptr[cColor] c_Color):
        inst = <Color>Color.__new__(Color)
        inst.c_Color = c_Color
        return inst

    @property
    def red(self):
        if not deref(self.c_Color).__isset.red:
            return None

        return self.c_Color.get().red

    @property
    def green(self):
        if not deref(self.c_Color).__isset.green:
            return None

        return self.c_Color.get().green

    @property
    def blue(self):
        if not deref(self.c_Color).__isset.blue:
            return None

        return self.c_Color.get().blue

    @property
    def alpha(self):
        if not deref(self.c_Color).__isset.alpha:
            return None

        return self.c_Color.get().alpha


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Color) and
                isinstance(other, Color)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cColor cself = deref((<Color>self).c_Color)
        cdef cColor cother = deref((<Color>other).c_Color)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Color self):
        if not self.__hash:
            self.__hash = hash((
            self.red,
            self.green,
            self.blue,
            self.alpha,
            ))
        return self.__hash

    def __repr__(Color self):
        return f'Color(red={repr(self.red)}, green={repr(self.green)}, blue={repr(self.blue)}, alpha={repr(self.alpha)})'


Color_defaults = Color()


cdef class Vehicle(thrift.py3.types.Struct):

    def __init__(
        Vehicle self,
        color=None,
        licensePlate=None,
        description=None,
        name=None,
        hasAC=None
    ):
        self.c_Vehicle = make_shared[cVehicle]()

        inst = self
        cdef shared_ptr[cColor] __color
        if color is not None:
            __color = (
            <Color?> color).c_Color
            deref(inst.c_Vehicle).color = deref(__color.get())
            deref(inst.c_Vehicle).__isset.color = True

        if licensePlate is not None:
            deref(inst.c_Vehicle).licensePlate = licensePlate.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.licensePlate = True

        if description is not None:
            deref(inst.c_Vehicle).description = description.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.description = True

        if name is not None:
            deref(inst.c_Vehicle).name = name.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.name = True

        if hasAC is not None:
            deref(inst.c_Vehicle).hasAC = hasAC
            deref(inst.c_Vehicle).__isset.hasAC = True


    cdef bytes _serialize(Vehicle self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cVehicle](deref(self.c_Vehicle.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cVehicle](deref(self.c_Vehicle.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cVehicle](deref(self.c_Vehicle.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Vehicle self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cVehicle](buf, deref(self.c_Vehicle.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cVehicle](buf, deref(self.c_Vehicle.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cVehicle](buf, deref(self.c_Vehicle.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Vehicle, serialize(self)))

    def __call__(
        Vehicle self,
        color=NOTSET,
        licensePlate=NOTSET,
        description=NOTSET,
        name=NOTSET,
        hasAC=NOTSET
    ):
        changes = any((
            color is not NOTSET,

            licensePlate is not NOTSET,

            description is not NOTSET,

            name is not NOTSET,

            hasAC is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Vehicle>Vehicle.__new__(Vehicle)
        inst.c_Vehicle = make_shared[cVehicle](deref(self.c_Vehicle))
        cdef Vehicle defaults = Vehicle_defaults

        # Convert None's to default value.
        if color is None:
            deref(inst.c_Vehicle).color = deref(defaults.c_Vehicle).color
            deref(inst.c_Vehicle).__isset.color = False
        if color is NOTSET:
            color = None
        if licensePlate is None:
            deref(inst.c_Vehicle).licensePlate = deref(defaults.c_Vehicle).licensePlate
            deref(inst.c_Vehicle).__isset.licensePlate = False
        if licensePlate is NOTSET:
            licensePlate = None
        if description is None:
            deref(inst.c_Vehicle).description = deref(defaults.c_Vehicle).description
            deref(inst.c_Vehicle).__isset.description = False
        if description is NOTSET:
            description = None
        if name is None:
            deref(inst.c_Vehicle).name = deref(defaults.c_Vehicle).name
            deref(inst.c_Vehicle).__isset.name = False
        if name is NOTSET:
            name = None
        if hasAC is None:
            deref(inst.c_Vehicle).hasAC = deref(defaults.c_Vehicle).hasAC
            deref(inst.c_Vehicle).__isset.hasAC = False
        if hasAC is NOTSET:
            hasAC = None

        cdef shared_ptr[cColor] __color
        if color is not None:
            __color = (
            <Color?> color).c_Color
            deref(inst.c_Vehicle).color = deref(__color.get())
            deref(inst.c_Vehicle).__isset.color = True

        if licensePlate is not None:
            deref(inst.c_Vehicle).licensePlate = licensePlate.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.licensePlate = True

        if description is not None:
            deref(inst.c_Vehicle).description = description.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.description = True

        if name is not None:
            deref(inst.c_Vehicle).name = name.encode('UTF-8')
            deref(inst.c_Vehicle).__isset.name = True

        if hasAC is not None:
            deref(inst.c_Vehicle).hasAC = hasAC
            deref(inst.c_Vehicle).__isset.hasAC = True

        return inst

    def __iter__(self):
        yield 'color', self.color
        yield 'licensePlate', self.licensePlate
        yield 'description', self.description
        yield 'name', self.name
        yield 'hasAC', self.hasAC

    def __bool__(self):
        return deref(self.c_Vehicle).__isset.color or deref(self.c_Vehicle).__isset.licensePlate or deref(self.c_Vehicle).__isset.description or deref(self.c_Vehicle).__isset.name or deref(self.c_Vehicle).__isset.hasAC

    @staticmethod
    cdef create(shared_ptr[cVehicle] c_Vehicle):
        inst = <Vehicle>Vehicle.__new__(Vehicle)
        inst.c_Vehicle = c_Vehicle
        return inst

    @property
    def color(self):
        if not deref(self.c_Vehicle).__isset.color:
            return None

        cdef shared_ptr[cColor] item
        if self.__color is None:
            item = make_shared[cColor](
                deref(self.c_Vehicle).color)
            self.__color = Color.create(item)
        return self.__color
        

    @property
    def licensePlate(self):
        if not deref(self.c_Vehicle).__isset.licensePlate:
            return None

        return self.c_Vehicle.get().licensePlate.decode('UTF-8')

    @property
    def description(self):
        if not deref(self.c_Vehicle).__isset.description:
            return None

        return self.c_Vehicle.get().description.decode('UTF-8')

    @property
    def name(self):
        if not deref(self.c_Vehicle).__isset.name:
            return None

        return self.c_Vehicle.get().name.decode('UTF-8')

    @property
    def hasAC(self):

        return <pbool> self.c_Vehicle.get().hasAC


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Vehicle) and
                isinstance(other, Vehicle)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cVehicle cself = deref((<Vehicle>self).c_Vehicle)
        cdef cVehicle cother = deref((<Vehicle>other).c_Vehicle)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Vehicle self):
        if not self.__hash:
            self.__hash = hash((
            self.color,
            self.licensePlate,
            self.description,
            self.name,
            self.hasAC,
            ))
        return self.__hash

    def __repr__(Vehicle self):
        return f'Vehicle(color={repr(self.color)}, licensePlate={repr(self.licensePlate)}, description={repr(self.description)}, name={repr(self.name)}, hasAC={repr(self.hasAC)})'


Vehicle_defaults = Vehicle()


cdef class Person(thrift.py3.types.Struct):

    def __init__(
        Person self,
        id=None,
        name=None,
        age=None,
        address=None,
        favoriteColor=None,
        friends=None,
        bestFriend=None,
        petNames=None,
        afraidOfAnimal=None,
        vehicles=None
    ):
        self.c_Person = make_shared[cPerson]()

        inst = self
        if id is not None:
            deref(inst.c_Person).id = id
            deref(inst.c_Person).__isset.id = True

        if name is not None:
            deref(inst.c_Person).name = name.encode('UTF-8')
            deref(inst.c_Person).__isset.name = True

        if age is not None:
            deref(inst.c_Person).age = age
            deref(inst.c_Person).__isset.age = True

        if address is not None:
            deref(inst.c_Person).address = address.encode('UTF-8')
            deref(inst.c_Person).__isset.address = True

        cdef shared_ptr[cColor] __favoriteColor
        if favoriteColor is not None:
            __favoriteColor = (
            <Color?> favoriteColor).c_Color
            deref(inst.c_Person).favoriteColor = deref(__favoriteColor.get())
            deref(inst.c_Person).__isset.favoriteColor = True

        cdef Set__PersonID _friends
        if friends is not None:
            _friends = Set__PersonID(friends)
            deref(inst.c_Person).friends = deref(_friends._set)
            deref(inst.c_Person).__isset.friends = True

        if bestFriend is not None:
            deref(inst.c_Person).bestFriend = bestFriend
            deref(inst.c_Person).__isset.bestFriend = True

        cdef Map__Animal_string _petNames
        if petNames is not None:
            _petNames = Map__Animal_string(petNames)
            deref(inst.c_Person).petNames = deref(_petNames._map)
            deref(inst.c_Person).__isset.petNames = True

        if afraidOfAnimal is not None:
            deref(inst.c_Person).afraidOfAnimal = Animal_to_cpp(afraidOfAnimal)
            deref(inst.c_Person).__isset.afraidOfAnimal = True

        cdef List__Vehicle _vehicles
        if vehicles is not None:
            _vehicles = List__Vehicle(vehicles)
            deref(inst.c_Person).vehicles = deref(_vehicles._vector)
            deref(inst.c_Person).__isset.vehicles = True


    cdef bytes _serialize(Person self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cPerson](deref(self.c_Person.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cPerson](deref(self.c_Person.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cPerson](deref(self.c_Person.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Person self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cPerson](buf, deref(self.c_Person.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cPerson](buf, deref(self.c_Person.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cPerson](buf, deref(self.c_Person.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Person, serialize(self)))

    def __call__(
        Person self,
        id=NOTSET,
        name=NOTSET,
        age=NOTSET,
        address=NOTSET,
        favoriteColor=NOTSET,
        friends=NOTSET,
        bestFriend=NOTSET,
        petNames=NOTSET,
        afraidOfAnimal=NOTSET,
        vehicles=NOTSET
    ):
        changes = any((
            id is not NOTSET,

            name is not NOTSET,

            age is not NOTSET,

            address is not NOTSET,

            favoriteColor is not NOTSET,

            friends is not NOTSET,

            bestFriend is not NOTSET,

            petNames is not NOTSET,

            afraidOfAnimal is not NOTSET,

            vehicles is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Person>Person.__new__(Person)
        inst.c_Person = make_shared[cPerson](deref(self.c_Person))
        cdef Person defaults = Person_defaults

        # Convert None's to default value.
        if id is None:
            deref(inst.c_Person).id = deref(defaults.c_Person).id
            deref(inst.c_Person).__isset.id = False
        if id is NOTSET:
            id = None
        if name is None:
            deref(inst.c_Person).name = deref(defaults.c_Person).name
            deref(inst.c_Person).__isset.name = False
        if name is NOTSET:
            name = None
        if age is None:
            deref(inst.c_Person).age = deref(defaults.c_Person).age
            deref(inst.c_Person).__isset.age = False
        if age is NOTSET:
            age = None
        if address is None:
            deref(inst.c_Person).address = deref(defaults.c_Person).address
            deref(inst.c_Person).__isset.address = False
        if address is NOTSET:
            address = None
        if favoriteColor is None:
            deref(inst.c_Person).favoriteColor = deref(defaults.c_Person).favoriteColor
            deref(inst.c_Person).__isset.favoriteColor = False
        if favoriteColor is NOTSET:
            favoriteColor = None
        if friends is None:
            deref(inst.c_Person).friends = deref(defaults.c_Person).friends
            deref(inst.c_Person).__isset.friends = False
        if friends is NOTSET:
            friends = None
        if bestFriend is None:
            deref(inst.c_Person).bestFriend = deref(defaults.c_Person).bestFriend
            deref(inst.c_Person).__isset.bestFriend = False
        if bestFriend is NOTSET:
            bestFriend = None
        if petNames is None:
            deref(inst.c_Person).petNames = deref(defaults.c_Person).petNames
            deref(inst.c_Person).__isset.petNames = False
        if petNames is NOTSET:
            petNames = None
        if afraidOfAnimal is None:
            deref(inst.c_Person).afraidOfAnimal = deref(defaults.c_Person).afraidOfAnimal
            deref(inst.c_Person).__isset.afraidOfAnimal = False
        if afraidOfAnimal is NOTSET:
            afraidOfAnimal = None
        if vehicles is None:
            deref(inst.c_Person).vehicles = deref(defaults.c_Person).vehicles
            deref(inst.c_Person).__isset.vehicles = False
        if vehicles is NOTSET:
            vehicles = None

        if id is not None:
            deref(inst.c_Person).id = id
            deref(inst.c_Person).__isset.id = True

        if name is not None:
            deref(inst.c_Person).name = name.encode('UTF-8')
            deref(inst.c_Person).__isset.name = True

        if age is not None:
            deref(inst.c_Person).age = age
            deref(inst.c_Person).__isset.age = True

        if address is not None:
            deref(inst.c_Person).address = address.encode('UTF-8')
            deref(inst.c_Person).__isset.address = True

        cdef shared_ptr[cColor] __favoriteColor
        if favoriteColor is not None:
            __favoriteColor = (
            <Color?> favoriteColor).c_Color
            deref(inst.c_Person).favoriteColor = deref(__favoriteColor.get())
            deref(inst.c_Person).__isset.favoriteColor = True

        cdef Set__PersonID _friends
        if friends is not None:
            _friends = Set__PersonID(friends)
            deref(inst.c_Person).friends = deref(_friends._set)
            deref(inst.c_Person).__isset.friends = True

        if bestFriend is not None:
            deref(inst.c_Person).bestFriend = bestFriend
            deref(inst.c_Person).__isset.bestFriend = True

        cdef Map__Animal_string _petNames
        if petNames is not None:
            _petNames = Map__Animal_string(petNames)
            deref(inst.c_Person).petNames = deref(_petNames._map)
            deref(inst.c_Person).__isset.petNames = True

        if afraidOfAnimal is not None:
            deref(inst.c_Person).afraidOfAnimal = Animal_to_cpp(afraidOfAnimal)
            deref(inst.c_Person).__isset.afraidOfAnimal = True

        cdef List__Vehicle _vehicles
        if vehicles is not None:
            _vehicles = List__Vehicle(vehicles)
            deref(inst.c_Person).vehicles = deref(_vehicles._vector)
            deref(inst.c_Person).__isset.vehicles = True

        return inst

    def __iter__(self):
        yield 'id', self.id
        yield 'name', self.name
        yield 'age', self.age
        yield 'address', self.address
        yield 'favoriteColor', self.favoriteColor
        yield 'friends', self.friends
        yield 'bestFriend', self.bestFriend
        yield 'petNames', self.petNames
        yield 'afraidOfAnimal', self.afraidOfAnimal
        yield 'vehicles', self.vehicles

    def __bool__(self):
        return deref(self.c_Person).__isset.id or deref(self.c_Person).__isset.name or deref(self.c_Person).__isset.age or deref(self.c_Person).__isset.address or deref(self.c_Person).__isset.favoriteColor or deref(self.c_Person).__isset.friends or deref(self.c_Person).__isset.bestFriend or deref(self.c_Person).__isset.petNames or deref(self.c_Person).__isset.afraidOfAnimal or deref(self.c_Person).__isset.vehicles

    @staticmethod
    cdef create(shared_ptr[cPerson] c_Person):
        inst = <Person>Person.__new__(Person)
        inst.c_Person = c_Person
        return inst

    @property
    def id(self):
        if not deref(self.c_Person).__isset.id:
            return None

        return self.c_Person.get().id

    @property
    def name(self):
        if not deref(self.c_Person).__isset.name:
            return None

        return self.c_Person.get().name.decode('UTF-8')

    @property
    def age(self):
        if not deref(self.c_Person).__isset.age:
            return None

        return self.c_Person.get().age

    @property
    def address(self):
        if not deref(self.c_Person).__isset.address:
            return None

        return self.c_Person.get().address.decode('UTF-8')

    @property
    def favoriteColor(self):
        if not deref(self.c_Person).__isset.favoriteColor:
            return None

        cdef shared_ptr[cColor] item
        if self.__favoriteColor is None:
            item = make_shared[cColor](
                deref(self.c_Person).favoriteColor)
            self.__favoriteColor = Color.create(item)
        return self.__favoriteColor
        

    @property
    def friends(self):
        if not deref(self.c_Person).__isset.friends:
            return None

        cdef shared_ptr[cset[int64_t]] item
        if self.__friends is None:
            item = make_shared[cset[int64_t]](
                deref(self.c_Person).friends)
            self.__friends = Set__PersonID.create(item)
        return self.__friends
        

    @property
    def bestFriend(self):
        if not deref(self.c_Person).__isset.bestFriend:
            return None

        return self.c_Person.get().bestFriend

    @property
    def petNames(self):
        if not deref(self.c_Person).__isset.petNames:
            return None

        cdef shared_ptr[cmap[cAnimal,string]] item
        if self.__petNames is None:
            item = make_shared[cmap[cAnimal,string]](
                deref(self.c_Person).petNames)
            self.__petNames = Map__Animal_string.create(item)
        return self.__petNames
        

    @property
    def afraidOfAnimal(self):
        if not deref(self.c_Person).__isset.afraidOfAnimal:
            return None

        cdef int value = <int> deref(self.c_Person).afraidOfAnimal
        try:
            return Animal(value)
        except ValueError:
            return thrift.py3.types.BadEnum(Animal, value)
        

    @property
    def vehicles(self):
        if not deref(self.c_Person).__isset.vehicles:
            return None

        cdef shared_ptr[vector[cVehicle]] item
        if self.__vehicles is None:
            item = make_shared[vector[cVehicle]](
                deref(self.c_Person).vehicles)
            self.__vehicles = List__Vehicle.create(item)
        return self.__vehicles
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Person) and
                isinstance(other, Person)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cPerson cself = deref((<Person>self).c_Person)
        cdef cPerson cother = deref((<Person>other).c_Person)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Person self):
        if not self.__hash:
            self.__hash = hash((
            self.id,
            self.name,
            self.age,
            self.address,
            self.favoriteColor,
            self.friends,
            self.bestFriend,
            self.petNames,
            self.afraidOfAnimal,
            self.vehicles,
            ))
        return self.__hash

    def __repr__(Person self):
        return f'Person(id={repr(self.id)}, name={repr(self.name)}, age={repr(self.age)}, address={repr(self.address)}, favoriteColor={repr(self.favoriteColor)}, friends={repr(self.friends)}, bestFriend={repr(self.bestFriend)}, petNames={repr(self.petNames)}, afraidOfAnimal={repr(self.afraidOfAnimal)}, vehicles={repr(self.vehicles)})'


Person_defaults = Person()


cdef class Set__PersonID:
    def __init__(self, items=None):
        if isinstance(items, Set__PersonID):
            self._set = (<Set__PersonID> items)._set
        else:
          self._set = make_shared[cset[int64_t]]()
          if items:
              for item in items:
                  deref(self._set).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[int64_t]] c_items):
        inst = <Set__PersonID>Set__PersonID.__new__(Set__PersonID)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int64_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__PersonID) and
                isinstance(other, Set__PersonID)):
            cself = deref((<Set__PersonID> self)._set)
            cother = deref((<Set__PersonID> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__PersonID):
            self = Set__PersonID(self)
        if not isinstance(other, Set__PersonID):
            other = Set__PersonID(other)

        cdef shared_ptr[cset[int64_t]] shretval = \
            make_shared[cset[int64_t]]()
        for citem in deref((<Set__PersonID> self)._set):
            if deref((<Set__PersonID> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__PersonID.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__PersonID):
            self = Set__PersonID(self)
        if not isinstance(other, Set__PersonID):
            other = Set__PersonID(other)

        cdef shared_ptr[cset[int64_t]] shretval = \
            make_shared[cset[int64_t]]()
        for citem in deref((<Set__PersonID> self)._set):
            if deref((<Set__PersonID> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__PersonID.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__PersonID):
            self = Set__PersonID(self)
        if not isinstance(other, Set__PersonID):
            other = Set__PersonID(other)

        cdef shared_ptr[cset[int64_t]] shretval = \
            make_shared[cset[int64_t]]()
        for citem in deref((<Set__PersonID> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__PersonID> other)._set):
                deref(shretval).insert(citem)
        return Set__PersonID.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__PersonID):
            self = Set__PersonID(self)
        if not isinstance(other, Set__PersonID):
            other = Set__PersonID(other)

        cdef shared_ptr[cset[int64_t]] shretval = \
            make_shared[cset[int64_t]]()
        for citem in deref((<Set__PersonID> self)._set):
            if deref((<Set__PersonID> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__PersonID> other)._set):
            if deref((<Set__PersonID> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__PersonID.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__PersonID)

cdef class Map__Animal_string:
    def __init__(self, items=None):
        if isinstance(items, Map__Animal_string):
            self._map = (<Map__Animal_string> items)._map
        else:
          self._map = make_shared[cmap[cAnimal,string]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[cAnimal,string](
                          Animal_to_cpp(key),
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[cAnimal,string]] c_items):
        inst = <Map__Animal_string>Map__Animal_string.__new__(Map__Animal_string)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef cAnimal ckey = Animal_to_cpp(key)
        cdef cmap[cAnimal,string].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cAnimal citem
        for pair in deref(self._map):
            citem = pair.first
            yield Animal(<int> citem)

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef cAnimal ckey = Animal_to_cpp(key)
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef cAnimal ckey = Animal_to_cpp(key)
        cdef cmap[cAnimal,string].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef cAnimal ckey
        cdef string citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (Animal(<int> ckey), bytes(citem).decode('UTF-8'))



Mapping.register(Map__Animal_string)

cdef class List__Vehicle:
    def __init__(self, items=None):
        if isinstance(items, List__Vehicle):
            self._vector = (<List__Vehicle> items)._vector
        else:
          self._vector = make_shared[vector[cVehicle]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref((<Vehicle> item).c_Vehicle))

    @staticmethod
    cdef create(
            shared_ptr[vector[cVehicle]] c_items):
        inst = <List__Vehicle>List__Vehicle.__new__(List__Vehicle)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cVehicle citem = (
            deref(self._vector.get())[index])
        return Vehicle.create(make_shared[cVehicle](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cVehicle citem = deref((<Vehicle> item).c_Vehicle)
        cdef vector[cVehicle] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cVehicle citem
        for citem in deref(self._vector):
            yield Vehicle.create(make_shared[cVehicle](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cVehicle citem
        cdef vector[cVehicle] vec = deref(
            self._vector.get())
        cdef vector[cVehicle].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Vehicle.create(make_shared[cVehicle](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cVehicle citem = deref((<Vehicle> item).c_Vehicle)
        cdef vector[cVehicle] vec = deref(self._vector.get())
        cdef vector[cVehicle].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cVehicle citem = deref((<Vehicle> item).c_Vehicle)
        cdef vector[cVehicle] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Vehicle)

PersonID = int
